/* eslint-disable */

!(function (a) {
  function b(d) {
    if (c[d]) return c[d].exports;
    var e = (c[d] = { i: d, l: !1, exports: {} });
    return a[d].call(e.exports, e, e.exports, b), (e.l = !0), e.exports;
  }
  var c = {};
  (b.m = a),
    (b.c = c),
    (b.d = function (a, c, d) {
      b.o(a, c) || Object.defineProperty(a, c, { enumerable: !0, get: d });
    }),
    (b.r = function (a) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(a, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(a, '__esModule', { value: !0 });
    }),
    (b.t = function (a, c) {
      if ((1 & c && (a = b(a)), 8 & c)) return a;
      if (4 & c && 'object' == typeof a && a && a.__esModule) return a;
      var d = Object.create(null);
      if (
        (b.r(d),
        Object.defineProperty(d, 'default', { enumerable: !0, value: a }),
        2 & c && 'string' != typeof a)
      )
        for (var f in a)
          b.d(
            d,
            f,
            function (b) {
              return a[b];
            }.bind(null, f)
          );
      return d;
    }),
    (b.n = function (a) {
      var c =
        a && a.__esModule
          ? function () {
              return a.default;
            }
          : function () {
              return a;
            };
      return b.d(c, 'a', c), c;
    }),
    (b.o = function (a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }),
    (b.p = ''),
    b((b.s = 0));
})([
  function (a, b, c) {
    const d = c(1),
      e = c(3);
    c(6);
    const f = { compileCrossword: d, CrosswordDOM: e };
    'undefined' != typeof window && (window.CrosswordsJS = f), (a.exports = f);
  },
  function (a, b, c) {
    function d(a, b) {
      let c = b;
      for (let d = 0; d < a.length; d++) {
        if (c <= a[d].length) return [a[d], c];
        c -= a[d].length;
      }
    }
    const f = c(2);
    a.exports = function (b) {
      if (!b)
        throw new Error(
          'The Crossword must be initialised with a crossword definition.'
        );
      const g = {
        width: b.width,
        height: b.height,
        acrossClues: [],
        downClues: [],
        cells: [],
      };
      if (
        void 0 === g.width ||
        null === g.width ||
        0 > g.width ||
        void 0 === g.height ||
        null === g.height ||
        0 > g.height
      )
        throw new Error('The crossword bounds are invalid.');
      g.cells = (function (a) {
        const b = a.width,
          c = a.height,
          d = Array(b);
        for (let b = 0; b < c; b++) {
          d[b] = Array(c);
          for (let e = 0; e < c; e++) d[b][e] = { crossword: a, x: b, y: e };
        }
        return d;
      })(g);
      const e = b.acrossClues.concat(b.downClues);
      for (let h = 0; h < e.length; h++) {
        const j = e[h],
          k = h < b.acrossClues.length,
          c = f(j.clue);
        if (
          ((c.code = c.number + (k ? 'a' : 'd')),
          (c.answer = j.answer),
          (c.x = j.x - 1),
          (c.y = j.y - 1),
          (c.across = k),
          (c.cells = []),
          (c.clueLabel = c.number + '.'),
          g[k ? 'acrossClues' : 'downClues'].push(c),
          0 > c.x || c.x >= g.width || 0 > c.y || c.y >= g.height)
        )
          throw new Error(`Clue ${c.code} doesn't start in the bounds.`);
        if (k) {
          if (c.x + c.totalLength > g.width)
            throw new Error(`Clue ${c.code} exceeds horizontal bounds.`);
        } else if (c.y + c.totalLength > g.height)
          throw new Error(`Clue ${c.code} exceeds vertical bounds.`);
        let { x: l, y: a } = c;
        for (let b = 0; b < c.totalLength; b++) {
          const e = g.cells[l][a];
          (e.light = !0),
            (e[k ? 'acrossClue' : 'downClue'] = c),
            (e[k ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] = b),
            c.cells.push(e);
          const [f, h] = d(c.answerStructure, b);
          if (
            (h === f.length - 1 &&
              '' !== f.terminator &&
              (e[c.across ? 'acrossTerminator' : 'downTerminator'] =
                f.terminator),
            c.answer)
          ) {
            if (
              void 0 !== e.answer &&
              ' ' !== e.answer &&
              e.answer !== c.answer[b]
            )
              throw new Error(
                `Clue ${c.code} answer at (${l + 1}, ${
                  a + 1
                }) is not coherent with previous clue (${
                  e.acrossClue.code
                }) answer.`
              );
            e.answer = c.answer[b];
          }
          if (0 == b) {
            if (e.clueLabel && e.clueLabel !== c.number)
              throw new Error(
                `Clue ${c.code} has a label which is inconsistent with another clue (${e.acrossClue.code}).`
              );
            e.clueLabel = c.number;
          }
          k ? l++ : a++;
        }
      }
      return (
        g.acrossClues.concat(g.downClues).forEach((a) => {
          if (!a.connectedClueNumbers) return;
          (a.connectedClues = a.connectedClueNumbers.map((a) =>
            'across' === a.direction
              ? g.acrossClues.find((b) => b.number === a.number)
              : 'down' === a.direction
              ? g.downClues.find((b) => b.number === a.number)
              : g.acrossClues.find((b) => b.number === a.number) ||
                g.downClues.find((b) => b.number === a.number)
          )),
            (a.answerStructureText =
              '(' +
              [a.answerStructureText]
                .concat(a.connectedClues.map((a) => a.answerStructureText))
                .join(',')
                .replace(/[()]/g, '') +
              ')');
          let b = 0;
          const c = [a].concat(a.connectedClues);
          c.forEach((a) => {
            0 < b && (a.previousClueSegment = c[b - 1]),
              b < c.length - 1 && (a.nextClueSegment = c[b + 1]),
              (a.parentClue = c[0]),
              b++;
          }),
            (a.clueLabel =
              [a.number]
                .concat(a.connectedClues.map((a) => a.number))
                .join(',') + '.'),
            a.connectedClues.forEach((a) => {
              (a.answerStructureText = null), (a.isConnectedClue = !0);
            });
        }),
        g
      );
    };
  },
  function (a) {
    const b = new RegExp(/^(\d+),?([\dad,]*).[\s]*(.*)[\s]*\(([\d,-]+)\)$/);
    a.exports = function (f) {
      if (!f) throw new Error("'clue' is required");
      if (!b.test(f))
        throw new Error(
          `Clue '${f}' does not meet the required structured '<Number>. Clue Text (<Answer structure>)'`
        );
      const [, e, g, h, j] = b.exec(f),
        i = parseInt(e, 10);
      let k = null;
      g &&
        (k = g.split(',').map((a) => {
          return {
            number: parseInt(a, 10),
            direction:
              ((b = a), /a$/.test(b) ? 'across' : /d$/.test(b) ? 'down' : null),
          };
          var b;
        }));
      const l = [],
        m = new RegExp(/([\d]+)([,-]?)(.*)/);
      for (let a = j; m.test(a); ) {
        const [, b, c, d] = m.exec(a);
        l.push({ length: parseInt(b, 10), terminator: c }), (a = d);
      }
      const a = l.reduce((a, b) => a + b.length, 0),
        d = `(${l.map((a) => `${a.length}${a.terminator}`).join('')})`;
      return {
        number: i,
        clue: h,
        connectedClueNumbers: k,
        answerStructure: l,
        answerStructureText: d,
        totalLength: a,
      };
    };
  },
  function (a, b, d) {
    function e(a, b, c) {
      const { document: d } = a;
      (this.crossword = b), (this.parentElement = c);
      const f = d.createElement('div');
      f.className = 'crossword';
      for (let g = 0; g < b.height; g++) {
        const a = d.createElement('div');
        (a.className = 'cwrow'), f.appendChild(a);
        for (let e = 0; e < b.width; e++) {
          const f = b.cells[e][g],
            i = this._createCellDOM(d, f);
          a.appendChild(i), h.add(f, i);
        }
      }
      const e = (a) => {
        const b = a.children[0].children[0].clientWidth;
        a.style.fontSize = 0.6 * b + 'px';
      };
      a.addEventListener('resize', () => e(f)),
        c.appendChild(f),
        e(f),
        (this.updateFontSize = () => e(f)),
        (this.crosswordElement = f);
    }
    const c = d(4),
      { removeClass: f, addClass: g } = d(5),
      h = new c();
    (e.prototype.selectClue = function (a) {
      (this.currentClue = a),
        this._updateDOM(),
        h.getCellElement(a.cells[0]).focus(),
        this._stateChange('clueSelected');
    }),
      (e.prototype.destroy = function () {
        h.removeCrosswordCells(this.crossword),
          this.parentElement.removeChild(this.crosswordElement),
          (this.onStateChanged = null);
      }),
      (e.prototype._stateChange = function (a, b) {
        const c = this.onStateChanged;
        c && c({ message: a, data: b });
      }),
      (e.prototype._createCellDOM = function (a, b) {
        const d = this,
          c = a.createElement('div');
        if (
          ((c.className = 'cwcell'),
          (b.cellElement = c),
          (c.className += b.light ? ' light' : ' dark'),
          !b.light)
        )
          return c;
        const e = a.createElement('input');
        if (
          ((e.maxLength = 1),
          b.answer && (e.value = b.answer),
          c.appendChild(e),
          b.clueLabel)
        ) {
          const d = a.createElement('div');
          (d.className = 'cwcluelabel'),
            (d.innerHTML = b.clueLabel),
            c.appendChild(d);
        }
        if (',' === b.acrossTerminator)
          e.className += ' cw-across-word-separator';
        else if ('-' === b.acrossTerminator) {
          const b = a.createElement('div');
          (b.className = 'cw-across-terminator'),
            (b.innerHTML = '|'),
            c.appendChild(b);
        } else if (',' === b.downTerminator)
          e.className += ' cw-down-word-separator';
        else if ('-' === b.downTerminator) {
          const b = a.createElement('div');
          (b.className = 'cw-down-terminator'),
            (b.innerHTML = '|'),
            c.appendChild(b);
        }
        return (
          e.addEventListener('focus', (a) => {
            const b = a.target.parentNode,
              e = h.getCell(b),
              { crossword: f } = e,
              g = e.acrossClue,
              i = e.downClue;
            (d.currentClue && (d.currentClue === g || d.currentClue === i)) ||
              ((d.currentClue =
                (g && !i) || (!g && i)
                  ? g || i
                  : g &&
                    d.currentClue &&
                    (g === d.currentClue.previousClueSegment ||
                      g === d.nextClueSegment)
                  ? g
                  : d.currentClue &&
                    (i === d.currentClue.previousClueSegment ||
                      i === d.nextClueSegment)
                  ? i
                  : 0 === e.downClueLetterIndex && 0 !== e.acrossClueLetterIndex
                  ? i
                  : g),
              d._updateDOM(),
              d._stateChange('clueSelected')),
              d._updateDOM(),
              d._stateChange('clueSelectedCustomEvent');
          }),
          c.addEventListener('keypress', (b) => {
            function e(a, b, c) {
              let d = null == a ? '' : a,
                f = '';
              for (; d.length <= b; ) d += ' ';
              const g = Math.max(b, d.length);
              for (let h = 0; h < g; h++) f += h === b ? c : d[h];
              return f;
            }
            32 === b.keyCode && b.preventDefault(), (b.target.value = '');
            const c = b.target.parentNode,
              f = h.getCell(c),
              { crossword: g } = f,
              i = d.currentClue,
              j = String.fromCharCode(b.keyCode);
            f.acrossClue &&
              (f.acrossClue.answer = e(
                f.acrossClue.answer,
                f.acrossClueLetterIndex,
                j
              )),
              f.downClue &&
                (f.downClue.answer = e(
                  f.downClue.answer,
                  f.downClueLetterIndex,
                  j
                ));
            const k =
              (f.acrossClue === i
                ? f.acrossClueLetterIndex
                : f.downClueLetterIndex) + 1;
            k < i.cells.length &&
              i.cells[k].cellElement.querySelector('input').focus(),
              k === i.cells.length &&
                i.nextClueSegment &&
                i.nextClueSegment.cells[0].cellElement
                  .querySelector('input')
                  .focus();
          }),
          c.addEventListener('keyup', () => {}),
          c
        );
      }),
      (e.prototype._updateDOM = function () {
        const a = this.currentClue,
          { crossword: b } = this;
        b.cells.forEach((a) => {
          a.forEach((a) => {
            a.light && f(h.getCellElement(a).querySelector('input'), 'active');
          });
        }),
          (a.parentClue
            ? [a.parentClue].concat(a.parentClue.connectedClues)
            : [a]
          ).forEach((a) => {
            a.cells.forEach((a) => {
              g(h.getCellElement(a).querySelector('input'), 'active');
            });
          });
      }),
      (a.exports = e);
  },
  function (a) {
    function b() {
      this.map = [];
    }
    (b.prototype.add = function (a, b) {
      this.map.push({ cell: a, cellElement: b });
    }),
      (b.prototype.getCellElement = function (a) {
        for (let b = 0; b < this.map.length; b++)
          if (this.map[b].cell === a) return this.map[b].cellElement;
        return null;
      }),
      (b.prototype.getCell = function (a) {
        for (let b = 0; b < this.map.length; b++)
          if (this.map[b].cellElement === a) return this.map[b].cell;
        return null;
      }),
      (b.prototype.removeCrosswordCells = function (a) {
        for (let b = 0; b < this.map.length; b++)
          this.map[b].cell.crossword === a && this.map.splice(b, 1);
      }),
      (a.exports = b);
  },
  function (a) {
    a.exports = {
      removeClass: function (a, b) {
        const c = new RegExp(`(?:^|\\s)${b}(?!\\S)`, 'g');
        a.className = a.className.replace(c, '');
      },
      addClass: function (a, b) {
        a.className += ' ' + b;
      },
    };
  },
  function () {},
]);
